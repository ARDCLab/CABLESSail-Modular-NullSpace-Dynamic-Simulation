classdef boom_component < component_BASE

    properties
        coordinate = state_vector({state(3, 'Position'), state(9, 'Vectorized DCM'), state_2D_elastic_coordinate(6, "elastic coordinates")});
        velocity = state_vector({state(3, 'Velocity'), state(3, 'Angular Velocity'), state(6, 'elastic_coordinates')});
        T2 = @(t) 0*t;
        T3 = @(t) 0*t;

    end % properites

    methods
        Omega_x = compute_Omega(obj, omega) % Function to build the large Omega matrix
    end

    methods
        function obj = boom_component()
            %METHOD1 Summary of this method goes here
            %   Detailed explanation goes here
            %
            % ----------------------------------------------------------- %
            % Call the super class constructor
            obj = obj@component_BASE();
            obj = build_constants_structure(obj);

        end % Function

        function [f_gen] = compute_cable_generalized_forces(obj, t, q_eps)
            % Computes the force magnitude generated by the cable tension
            % and beam defleciton at each beam spreader location. The force
            % component parallel to the rigid beam location is ignored, as
            % this would be counteracted by the boom support and motor
            % mounting without any affect on deflection.
            %
            % Inputs
            % q_eps : Elastic coordinate agreeing with the coordinate
            % dimension that is in the component coordinates state vector.
            %
            % Outputs
            % F : Matrix of force values where the columns are the reaction
            % force at each plate location resolved in the component body
            % frame.
            %-------------------------------------------------------------%
            
            % Extract the tensions at the current time
            T2 = obj.T2(t);
            T3 = obj.T3(t);

            if (T2==0 && T3 ==0)
                f_gen = [ zeros(length(q_eps), 1)];
                return
            end


            % x location of spread plates
            x = obj.const.x_plates;
            
            % Make sure inputs are in the expeced form
            q_eps = reshape(q_eps, length(q_eps), 1); % column
            n_eps = obj.coordinate.states{3}.dimension/2;
            q2 = q_eps(1:n_eps);
            q3 = q_eps(n_eps+1:end);
            
            % Compute the deflection
            u2 = (obj.const.psi_X * q2)'; % 'Wide" matrix output
            u3 = (obj.const.psi_X * q3)';
            u = [u2; u3];
            
            % Form locationvector for each element wrt base resolved in the
            % body frame
            d2 = [x ; u2; zeros(1,length(x))]; % Location of each plate
            r2 = d2(:, 2:end) - d2(:, 1:end-1); % Relative vector between paltes
            d3 = [x ; zeros(1,length(x)); u3 ]; % Location of each plate
            r3 = d3(:, 2:end) - d3(:, 1:end-1); % Relative vector between paltes

            % TODO: From here down this only really works for one tension
            % at a time. You need to compute the unit vector seperately for
            % each bending direciton and then multiply those unit vector
            % difference by the tension magnitude.
            e2_cables = r2./vecnorm(r2); % Unit vector of cable between plates
            e3_cables = r3./vecnorm(r3);

            % Residual reaction force balancing the tensions
            F2 = (e2_cables(:,2:end) - e2_cables(:,1:end-1)); 
            F3 = (e3_cables(:,2:end) - e3_cables(:,1:end-1)); 
            F2 = T2*F2;
            F3 = T3*F3;
            
            F_plate = -(F2+F3);
            
            % Compute the generalized force on the elastic coordiantes
            f_gen_q = zeros(6,1);
            for lv1 = 1:length(obj.const.x_plates)-2
                xi = obj.const.x_plates(lv1+1);
                f_gen_q = f_gen_q + (-F_plate(:, lv1)'*[zeros(1,6); obj.const.PSI_FH(xi)])';
            end

            % Compute the generalized force from the tip moment
            f_q2_cable_momet = T2 * obj.const.Plate_total_radius * obj.const.dpsi_i_dx_FH(obj.const.Boom_Length);
            f_q3_cable_momet = T3 * obj.const.Plate_total_radius * obj.const.dpsi_i_dx_FH(obj.const.Boom_Length);

            % Add generalized force
            f_gen_q = f_gen_q + [f_q2_cable_momet, f_q3_cable_momet]';

            % Create entire generalized force vector
            f_gen = f_gen_q;

        end

        function obj = build_constants_structure(obj)
            %METHOD1 Summary of this method goes here
            %   Detailed explanation goes here
            %
            % ----------------------------------------------------------- %

            % Material constants ---------------------------------------- %
            % ----------------------------------------------------------- %
            % TODO: Make this match the master list on BOX
            obj.const.Length = 29.5; % meter Length of boom
            obj.const.Boom_Length = 29.5;
            % boom.Modulus_Elasticity = 228*1e9; % Pascals (Gpa = 1e9 = 10^9)
            %obj.const.Modulus_Elasticity = 228*1e3; % Pascals (Gpa = 1e9 = 10^9)
            obj.const.Modulus_Elasticity = 2.1645*1e7; % Use the more accurate value that agrees with the red wire paper
            % The results in a flexuarl rigidity of 1700 Nm (units??)
            %boom.Modulus_Elasticity = 228*1e5;
            obj.const.Radius = 0.1; % m Radius of circular boom cross-section
            obj.const.Plate_h = 0.1; %m Height of plate 'above' boom cross-section
            obj.const.Plate_total_radius = obj.const.Radius + obj.const.Plate_h;
            %boom.CrossSection_MOI = 4.99*10^(-10); % m^4
            obj.const.CrossSection_MOI =pi/64*(2*obj.const.Radius)^4; % m^4 2nd moment of area
            obj.const.m = 3; % kg
            obj.const.rho = obj.const.m/(pi*obj.const.Radius^2*obj.const.Length); % kg/m^3
            obj.const.rho_L = obj.const.m/(obj.const.Length); % kg/m

            

            % Basis Functions etc --------------------------------------- %
            % ----------------------------------------------------------- %
            syms x;
            psi_i = [(x/obj.const.Length).^2 (x/obj.const.Length).^3 (x/obj.const.Length).^4];% Pick some basis functions
            n_psi = length(psi_i);
            Psi = [psi_i, zeros(1,n_psi); zeros(1,n_psi), psi_i ];
            obj.const.PSI = Psi;
            obj.const.PSI_FH = matlabFunction(Psi);
            dpsi_dx2 = diff(Psi,x,2);
            obj.const.psi_i_FH = matlabFunction(psi_i);
            obj.const.dpsi_i_dx_FH = matlabFunction(diff(psi_i,x,1));
            % Compute int Psi^T * Psi dx
            obj.const.P_B_i = double(int(obj.const.rho_L*(Psi'*Psi), x, 0, obj.const.Length));

            % TODO: If you create a set method do you need to do this
            % obj... = obj..() thing? I would like to do just obj.set();
            obj.coordinate.states{3}.basis_functions = obj.const.PSI;
            obj.coordinate.states{3}.Length =  obj.const.Length;
            
            % Spreader plates-------------------------------------------- %
            % ----------------------------------------------------------- %
            Nplates = 20; % Number of plates
            obj.const.x_plates = linspace(0,obj.const.Length, Nplates);
            obj.const.psi_X = obj.const.psi_i_FH(obj.const.x_plates');


            % Initial Cable Tensions ------------------------------------ %
            % ----------------------------------------------------------- %
            obj.const.T2 = 0; % + bends in the i2 direction (in plane)
            obj.const.T3 = 0; % + bends in the i3 direciton (out of plane)

            % Positive def check ------------------- %
            % Pdefint = [eye(3), [zeros(1,6); Psi];
            %            [zeros(1,6); Psi]', [zeros(1,6); Psi]'*[zeros(1,6); Psi]];
            % m_check = double(int(Pdefint, x, 0, boom.Length));
            % -------------------------------------- %
            
            % Stiffness matrix ------------------------------------------ %
            % ----------------------------------------------------------- %
            K_integrand = blkdiag(zeros(3), zeros(9), obj.const.Modulus_Elasticity*obj.const.CrossSection_MOI*(dpsi_dx2'*dpsi_dx2));
            % Constant for these booms, so define it in the const structure
            obj.const.K = double(int(K_integrand, x, 0, obj.const.Length));
            
            % Mass Matrix ----------------------------------------------- %
            % ----------------------------------------------------------- %
            % Symblic vector function used to check mass matrix
            obj.const.r_dmi_i = [x; 0; 0];
            
            % Integrals for mass matrix
            syms x y z;
            Gint0 = crossr([x,y,z]')'*[zeros(1,6); Psi];
            Gint1 = int(Gint0, z, -sqrt(obj.const.Radius^2 - y^2), sqrt(obj.const.Radius^2 - y^2));
            Gint2 = int(Gint1, y, -obj.const.Radius, obj.const.Radius);
            obj.const.G_B_i = double(obj.const.rho*int(Gint2, x, 0, obj.const.Length));
            
            % Construct H for booms
            obj.const.H_B_i = double(int(obj.const.rho_L*[zeros(1,2*n_psi); Psi], x, [0, obj.const.Length]));
            
            % Moment of inertia tensor of boom about the base
            obj.const.I_b_i = obj.const.m*[1/2*obj.const.Radius^2, 0, 0;
                    0, 1/3*obj.const.Length^2 + 1/4*obj.const.Radius^2, 0;
                    0, 0, 1/3*obj.const.Length^2 + 1/4*obj.const.Radius^2];
            
            % MOI check ---------------------------- %
                % syms x y z;
                % Iint0 = crossr([x,y,z]')'*crossr([x,y,z]');
                % Iint1 = int(Iint0, z, -sqrt(obj.const.Radius^2 - y^2), sqrt(obj.const.Radius^2 - y^2));
                % Iint2 = int(Iint1, y, -obj.const.Radius, obj.const.Radius);
                % I_b_i = double(int(obj.const.rho*Iint2, x, 0, obj.const.Length));
            % -------------------------------------- %
            
            % First moment of mass
            obj.const.c_B_i = obj.const.m*[obj.const.Length/2; 0; 0];
            obj.const.c_B_ix = crossr(obj.const.c_B_i);
            
        end

    end % Methods
end % classdef